<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Mosaic Pipeline Configurator â€” Full</title>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/drawflow/dist/drawflow.min.css" />
<style>
:root {
  --bg: #0f0f0f;
  --panel: #181818;
  --muted: #444;
  --accent: #0077ff;
  --step: #28a745;
  --display: #ffc107;
  color-scheme: dark;
}
body {
  margin: 0;
  font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  background: var(--bg);
  color: #eee;
}
header {
  background: #141414;
  padding: 10px 12px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  border-bottom: 1px solid #222;
}
header .left { display: flex; gap: 8px; align-items: center; }
button {
  background: var(--muted);
  border: none;
  color: #fff;
  padding: 8px 10px;
  border-radius: 8px;
  cursor: pointer;
}
button:hover { background: #5a5a5a; }
#workspace { display: flex; height: calc(100vh - 56px); }
#drawflow { flex: 1; background: #0b0b0b; }
#sidebar {
  width: 320px;
  background: var(--panel);
  border-left: 1px solid #222;
  padding: 12px;
  box-sizing: border-box;
  overflow: auto;
}
textarea {
  width:100%;
  height:320px;
  background:#111;
  color:#eee;
  border:1px solid #333;
  border-radius:6px;
  padding:8px;
  font-family: monospace;
  font-size:13px;
}
.legend { display:flex; gap:8px; margin:8px 0 16px; }
.chip { padding:6px 8px; border-radius:6px; font-size:13px; }
.chip.source { background:var(--accent); color:#fff; }
.chip.step { background:var(--step); color:#fff; }
.chip.display { background:var(--display); color:#000; }
.small { font-size:13px; color:#bbb; margin-top:8px; }

/* Node colors */
.df-node.type-source { background: var(--accent); color: #fff; }
.df-node.type-step { background: var(--step); color: #fff; }
.df-node.type-display { background: var(--display); color: #000; }

/* Step parameters */
.step-params { margin-top: 6px; display: flex; flex-direction: column; gap: 4px; width: 100%; }
.param-row { display:flex; gap:4px; width: 100%; }
.param-row input { flex:1; min-width:0; padding:2px 4px; font-size:12px; border-radius:4px; border:1px solid #333; background:#222; color:#fff; }
.param-row button { padding:2px 6px; font-size:12px; cursor:pointer; }
.add-param-btn { margin-top:4px; font-size:12px; padding:2px 6px; cursor:pointer; background:#555; color:#fff; border-radius:4px; border:none; }
.add-param-btn:hover { background:#777; }
</style>
</head>
<body>
<header>
<div class="left">
  <button id="btnLoad">Load YAML</button>
  <button id="btnExport">Export YAML</button>
  <button id="btnAddSource">Add Node</button>
  <button id="btnAddStep">Add Step</button>
  <button id="btnAddDisplay">Add Display</button>
</div>
<div>
  <strong>ðŸ§© Mosaic Pipeline Configurator â€” Full</strong>
</div>
</header>

<div id="workspace">
  <div id="drawflow"></div>
  <div id="sidebar">
    <h3>YAML I/O</h3>
    <textarea id="yamlArea">---
nodes:
- node-4
pipelines:
  raw:
    display_name: Raw
    pipeline:
      - step: passthrough
        params: {}
  sumthing:
    display_name: Sum thing
    pipeline:
      - step: moving_average
        params: {}
      - step: zscore
        params: {}
  avg:
    display_name: Avg
    pipeline:
      - step: mean
        params: {}
</textarea>

    <div class="legend">
      <div class="chip source">Source (node)</div>
      <div class="chip step">Processing step</div>
      <div class="chip display">Display (endpoint)</div>
    </div>
    <div class="small">
      Usage:
      <ol>
        <li>Click <b>Load YAML</b> to render the graph.</li>
        <li>Drag nodes, connect ports (drag from a node output to another node input).</li>
        <li>Click + on a step to add parameters.</li>
        <li>Ensure every path starts at a <i>source</i> and ends at a <i>display</i>.</li>
        <li>Click <b>Export YAML</b> to get YAML.</li>
      </ol>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/drawflow/dist/drawflow.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js"></script>

<script>
const container = document.getElementById("drawflow");
const editor = new Drawflow(container);
editor.reroute = true;
editor.start();

// Local functions dictionary instead of fetch
const functionsList = {
  moving_average:{}, zscore:{}, mean:{}, min:{}, max:{}, passthrough:{}
};

// escape html
function escapeHtml(s){return String(s).replace(/[&<>"']/g,m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));}

// add node
function addNodeTyped(name,type,x=100,y=100,extraData={}) {
  const data = Object.assign({}, extraData,{_type:type});
  let html = `<div style="padding:8px 12px;font-weight:600">${escapeHtml(name)}</div>`;
  if(type==='step'){ 
    html+=`<div class="step-params" id="params-${name}"></div><button class="add-param-btn" onclick="addParam('${name}')">+ Add Param</button>`;
  }
  let inputs=0, outputs=0;
  if(type==='source'){ inputs=0; outputs=1; } 
  else if(type==='step'){ inputs=1; outputs=1; } 
  else if(type==='display'){ inputs=1; outputs=0; }
  const id = editor.addNode(name,inputs,outputs,x,y,name,data,html,false);
  setTimeout(()=>{
    const el=document.getElementById('node-'+id);
    if(!el) return;
    el.classList.add('df-node');
    if(type==='source') el.classList.add('type-source');
    if(type==='step') el.classList.add('type-step');
    if(type==='display') el.classList.add('type-display');
  },50);
  return id;
}

// add step param
function addParam(nodeName){
  const container=document.querySelector(`#params-${nodeName}`);
  if(!container) return;
  const row=document.createElement('div'); row.className='param-row';
  const nameInput=document.createElement('input'); nameInput.placeholder='param name';
  const valueInput=document.createElement('input'); valueInput.placeholder='value';
  const delBtn=document.createElement('button'); delBtn.textContent='x';
  delBtn.onclick=()=>row.remove();
  row.appendChild(nameInput); row.appendChild(valueInput); row.appendChild(delBtn);
  container.appendChild(row);
}

// build from YAML with structured spacing
function buildFromYAML(){
  try{
    editor.clear();
    const yamlText=document.getElementById('yamlArea').value;
    const cfg=jsyaml.load(yamlText)||{};
    const sourcesCfg=Array.isArray(cfg.nodes)?cfg.nodes:[];
    const pipelinesCfg=cfg.pipelines||{};
    const sourceMap={};
    let sy = 80;
    const verticalSpacing = 180;
    const stepSpacing = 200;

    // add source nodes with spacing
    sourcesCfg.forEach((n, idx)=>{
      const id=addNodeTyped(n,'source',60,sy + idx*verticalSpacing,{nodeName:n});
      sourceMap[n]=id;
    });

    let baseY = 80;
    for(const [pname,pinfo] of Object.entries(pipelinesCfg)){
      const displayName = pinfo.display_name || pname;
      const steps = Array.isArray(pinfo.pipeline) ? pinfo.pipeline : [];
      const firstSourceName = sourcesCfg.length ? sourcesCfg[0] : 'node-1';
      if(!sourcesCfg.length){
        const id = addNodeTyped(firstSourceName,'source',60,baseY,{nodeName:firstSourceName});
        sourceMap[firstSourceName] = id;
      }
      let prevId = sourceMap[firstSourceName];
      let sx = 260;

      for(let i=0; i<steps.length; i++){
        const s = steps[i];
        const stepId = addNodeTyped(
          s.step || ('step_'+i),
          'step',
          sx + i*stepSpacing,
          baseY,
          {params: s.params || {}}
        );
        editor.addConnection(prevId, stepId, 'output_1', 'input_1');
        prevId = stepId;
      }

      const dispId = addNodeTyped(displayName,'display',sx + steps.length*stepSpacing, baseY, {displayName});
      editor.addConnection(prevId, dispId, 'output_1', 'input_1');

      baseY += verticalSpacing;
    }
  }catch(err){alert("Error parsing YAML: "+err); console.error(err);}
}

// export YAML
function exportToYAML(){
  const exported=editor.export();
  if(!exported||!exported.drawflow||!exported.drawflow.Home){ alert("Nothing to export."); return; }
  const nodesObj=exported.drawflow.Home.data||{};
  const nodes=Object.values(nodesObj);
  const byId={}; nodes.forEach(n=>byId[n.id]=n);
  const adj={}; nodes.forEach(n=>{ adj[n.id]=[]; if(!n.outputs) return; Object.values(n.outputs).forEach(port=>{ if(!port.connections) return; port.connections.forEach(c=>adj[n.id].push(c.node)); }); });
  const sourceNodes=nodes.filter(n=>n.data&&n.data._type==='source');
  const pipelines={};
  function normalizeKey(displayName){ return String(displayName).trim().toLowerCase().replace(/\s+/g,'_'); }
  for(const src of sourceNodes){
    const stack=[[src.id,[]]];
    const visited=new Set();
    while(stack.length){
      const [curId,path]=stack.pop();
      const neighbors=adj[curId]||[];
      for(const nxt of neighbors){
        const newPath=path.concat([nxt]);
        const keyStr=newPath.join(',');
        if(visited.has(keyStr)) continue;
        visited.add(keyStr);
        const nxtNode=byId[nxt];
        if(!nxtNode) continue;
        if(nxtNode.data&&nxtNode.data._type==='display'){
          const fullSeq=[src.id].concat(newPath);
          const pipelineArr=[];
          for(let i=1;i<fullSeq.length-1;i++){
            const nid=fullSeq[i]; const node=byId[nid]; if(!node) continue;
            if(node.data&&node.data._type==='step'){
              const params={};
              const paramDiv=document.querySelector(`#params-${node.name}`);
              if(paramDiv){
                Array.from(paramDiv.querySelectorAll('.param-row')).forEach(r=>{
                  const [n,v]=r.querySelectorAll('input');
                  if(n.value) params[n.value]=v.value;
                });
              }
              pipelineArr.push({step: node.name, params: params});
            }
          }
          const displayNode=byId[newPath[newPath.length-1]];
          const displayName=(displayNode.data&&displayNode.data.displayName)?displayNode.data.displayName:displayNode.name;
          let key=normalizeKey(displayName);
          let suffix=1; let finalKey=key;
          while(pipelines[finalKey]){ finalKey=key+'_'+(++suffix); }
          pipelines[finalKey]={display_name:displayName, pipeline:pipelineArr};
        } else stack.push([nxt,newPath]);
      }
    }
  }
  const nodeNames=sourceNodes.map(n=>n.data.nodeName||n.name);
  const out={nodes: nodeNames.length?nodeNames:['node-4'], pipelines: pipelines};
  document.getElementById('yamlArea').value=jsyaml.dump(out,{lineWidth:120});
}

// --- UI hooks ---
document.getElementById('btnLoad').addEventListener('click',buildFromYAML);
document.getElementById('btnExport').addEventListener('click',exportToYAML);

// Add new Source Node
document.getElementById('btnAddSource').addEventListener('click',()=>{
  const n=prompt("Node name:","node_new"); if(!n) return;
  addNodeTyped(n,'source',100+Math.random()*300,120+Math.random()*250,{nodeName:n});
});

// Add Step
document.getElementById('btnAddStep').addEventListener('click',()=>{
  const fNames = Object.keys(functionsList);
  const choice = prompt("Step name:\n"+fNames.join("\n"), fNames[0]);
  if(!choice) return;
  addNodeTyped(choice,'step',200+Math.random()*300,120+Math.random()*250,{params:{}});
});

// Add Display
document.getElementById('btnAddDisplay').addEventListener('click',()=>{
  const n=prompt("Display name","new_display"); if(!n) return;
  addNodeTyped(n,'display',400+Math.random()*300,120+Math.random()*250,{displayName:n});
});

// auto-load initial YAML with spacing
setTimeout(buildFromYAML,50);
</script>
</body>
</html>
